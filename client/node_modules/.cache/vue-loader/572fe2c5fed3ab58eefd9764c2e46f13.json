{"remainingRequest":"C:\\projects\\kube-dashboard\\client\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\projects\\kube-dashboard\\client\\node_modules\\vue-kanban\\src\\components\\Kanban.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\projects\\kube-dashboard\\client\\node_modules\\vue-kanban\\src\\components\\Kanban.vue","mtime":499162500000},{"path":"C:\\projects\\kube-dashboard\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\projects\\kube-dashboard\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"C:\\projects\\kube-dashboard\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\projects\\kube-dashboard\\client\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport dragula from 'dragula';\nimport { Machine } from 'xstate';\n\nexport default {\n  name: 'KanbanBoard',\n\n  props: {\n    stages: {\n      type: Array,\n      required: true,\n    },\n    blocks: {\n      type: Array,\n      required: true,\n    },\n    config: {\n      type: Object,\n      default: () => ({}),\n    },\n    stateMachineConfig: {\n      type: Object,\n      default: null,\n    },\n    idProp: {\n      type: String,\n      default: 'id',\n    },\n    statusProp: {\n      type: String,\n      default: 'status',\n    },\n  },\n\n  data() {\n    return {\n      machine: null,\n    };\n  },\n\n  computed: {\n    localBlocks() {\n      return this.blocks;\n    },\n  },\n\n  methods: {\n    getBlocks(status) {\n      return this.localBlocks.filter(block => block[this.statusProp] === status);\n    },\n\n    findPossibleTransitions(sourceState) {\n      return this.machine.config.states[sourceState].on || {};\n    },\n\n    findTransition(target, source) {\n      const targetState = target.dataset.status;\n      const sourceState = source.dataset.status;\n      const possibleTransitions = this.findPossibleTransitions(sourceState);\n      return Object.keys(possibleTransitions)\n        .find(transition => possibleTransitions[transition] === targetState);\n    },\n\n    accepts(block, target, source) {\n      if (!this.machine) return true;\n      const targetState = target.dataset.status;\n      const sourceState = source.dataset.status;\n      return Object.values(this.findPossibleTransitions(sourceState)).includes(targetState);\n    },\n\n    allowedTargets(el, source) {\n      const block = this.localBlocks.find(b => b[this.idProp] === el.dataset.blockId);\n      return this.drake.containers.filter(c => this.config.accepts(block, c, source));\n    },\n\n    forbiddenTargets(el, source) {\n      return this.drake.containers.filter(c => !this.allowedTargets(el, source).includes(c));\n    },\n  },\n\n  updated() {\n    this.drake.containers = this.$refs.list;\n    this.drake.mirrorContainer = this.$el;\n  },\n\n  mounted() {\n    this.config.accepts = this.config.accepts || this.accepts;\n    this.config.mirrorContainer = this.$el;\n    this.drake = dragula(this.$refs.list, this.config)\n    .on('drag', (el, source) => {\n      this.$emit('drag', el, source);\n      el.classList.add('is-moving');\n      this.allowedTargets(el, source).forEach(c => c.classList.add('allowed'));\n      this.forbiddenTargets(el, source).forEach(c => c.classList.add('forbidden'));\n    })\n    .on('dragend', (el) => {\n      this.$emit('dragend', el);\n      el.classList.remove('is-moving');\n      this.drake.containers.forEach(c => c.classList.remove('allowed', 'forbidden'));\n      window.setTimeout(() => {\n        el.classList.add('is-moved');\n        window.setTimeout(() => {\n          el.classList.remove('is-moved');\n        }, 600);\n      }, 100);\n    })\n    .on('drop', (block, list, source, sibling) => {\n      this.$emit('drop', block, list, source, sibling);\n      let index = 0;\n      for (index = 0; index < list.children.length; index += 1) {\n        if (list.children[index].classList.contains('is-moving')) break;\n      }\n\n      let newState = list.dataset.status;\n\n      if (this.machine) {\n        const transition = this.findTransition(list, source);\n        if (!transition) return;\n        newState = this.machine.transition(source.dataset.status, transition).value;\n      }\n\n      this.$emit('update-block', block.dataset.blockId, newState, index);\n    })\n    .on('cancel', (el, container, source) => {\n      this.$emit('cancel', el, container, source);\n    })\n    .on('remove', (el, container, source) => {\n      this.$emit('remove', el, container, source);\n    })\n    .on('shadow', (el, container, source) => {\n      this.$emit('shadow', el, container, source);\n    })\n    .on('over', (el, container, source) => {\n      this.$emit('over', el, container, source);\n    })\n    .on('out', (el, container, source) => {\n      this.$emit('out', el, container, source);\n    })\n    .on('cloned', (clone, original, type) => {\n      this.$emit('cloned', clone, original, type);\n    });\n    this.$emit('init', this.drake);\n  },\n\n  created() {\n    if (!this.stateMachineConfig) return;\n    this.machine = Machine(this.stateMachineConfig);\n  },\n};\n",{"version":3,"sources":["Kanban.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"Kanban.vue","sourceRoot":"node_modules/vue-kanban/src/components","sourcesContent":["<template>\n  <div class=\"drag-container\">\n    <ul class=\"drag-list\">\n      <li v-for=\"stage in stages\" class=\"drag-column\" :class=\"{['drag-column-' + stage]: true}\" :key=\"stage\">\n        <span class=\"drag-column-header\">\n          <slot :name=\"stage\">\n            <h2>{{ stage }}</h2>\n          </slot>\n        </span>\n        <div class=\"drag-options\"></div>\n        <ul class=\"drag-inner-list\" ref=\"list\" :data-status=\"stage\">\n          <li class=\"drag-item\" v-for=\"block in getBlocks(stage)\" :data-block-id=\"block[idProp]\" :key=\"block[idProp]\">\n            <slot :name=\"block[idProp]\">\n              <strong>{{ block[statusProp] }}</strong>\n              <div>{{ block[idProp] }}</div>\n            </slot>\n          </li>\n        </ul>\n        <div class=\"drag-column-footer\">\n            <slot :name=\"`footer-${stage}`\"></slot>\n        </div>\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\n  import dragula from 'dragula';\n  import { Machine } from 'xstate';\n\n  export default {\n    name: 'KanbanBoard',\n\n    props: {\n      stages: {\n        type: Array,\n        required: true,\n      },\n      blocks: {\n        type: Array,\n        required: true,\n      },\n      config: {\n        type: Object,\n        default: () => ({}),\n      },\n      stateMachineConfig: {\n        type: Object,\n        default: null,\n      },\n      idProp: {\n        type: String,\n        default: 'id',\n      },\n      statusProp: {\n        type: String,\n        default: 'status',\n      },\n    },\n\n    data() {\n      return {\n        machine: null,\n      };\n    },\n\n    computed: {\n      localBlocks() {\n        return this.blocks;\n      },\n    },\n\n    methods: {\n      getBlocks(status) {\n        return this.localBlocks.filter(block => block[this.statusProp] === status);\n      },\n\n      findPossibleTransitions(sourceState) {\n        return this.machine.config.states[sourceState].on || {};\n      },\n\n      findTransition(target, source) {\n        const targetState = target.dataset.status;\n        const sourceState = source.dataset.status;\n        const possibleTransitions = this.findPossibleTransitions(sourceState);\n        return Object.keys(possibleTransitions)\n          .find(transition => possibleTransitions[transition] === targetState);\n      },\n\n      accepts(block, target, source) {\n        if (!this.machine) return true;\n        const targetState = target.dataset.status;\n        const sourceState = source.dataset.status;\n        return Object.values(this.findPossibleTransitions(sourceState)).includes(targetState);\n      },\n\n      allowedTargets(el, source) {\n        const block = this.localBlocks.find(b => b[this.idProp] === el.dataset.blockId);\n        return this.drake.containers.filter(c => this.config.accepts(block, c, source));\n      },\n\n      forbiddenTargets(el, source) {\n        return this.drake.containers.filter(c => !this.allowedTargets(el, source).includes(c));\n      },\n    },\n\n    updated() {\n      this.drake.containers = this.$refs.list;\n      this.drake.mirrorContainer = this.$el;\n    },\n\n    mounted() {\n      this.config.accepts = this.config.accepts || this.accepts;\n      this.config.mirrorContainer = this.$el;\n      this.drake = dragula(this.$refs.list, this.config)\n      .on('drag', (el, source) => {\n        this.$emit('drag', el, source);\n        el.classList.add('is-moving');\n        this.allowedTargets(el, source).forEach(c => c.classList.add('allowed'));\n        this.forbiddenTargets(el, source).forEach(c => c.classList.add('forbidden'));\n      })\n      .on('dragend', (el) => {\n        this.$emit('dragend', el);\n        el.classList.remove('is-moving');\n        this.drake.containers.forEach(c => c.classList.remove('allowed', 'forbidden'));\n        window.setTimeout(() => {\n          el.classList.add('is-moved');\n          window.setTimeout(() => {\n            el.classList.remove('is-moved');\n          }, 600);\n        }, 100);\n      })\n      .on('drop', (block, list, source, sibling) => {\n        this.$emit('drop', block, list, source, sibling);\n        let index = 0;\n        for (index = 0; index < list.children.length; index += 1) {\n          if (list.children[index].classList.contains('is-moving')) break;\n        }\n\n        let newState = list.dataset.status;\n\n        if (this.machine) {\n          const transition = this.findTransition(list, source);\n          if (!transition) return;\n          newState = this.machine.transition(source.dataset.status, transition).value;\n        }\n\n        this.$emit('update-block', block.dataset.blockId, newState, index);\n      })\n      .on('cancel', (el, container, source) => {\n        this.$emit('cancel', el, container, source);\n      })\n      .on('remove', (el, container, source) => {\n        this.$emit('remove', el, container, source);\n      })\n      .on('shadow', (el, container, source) => {\n        this.$emit('shadow', el, container, source);\n      })\n      .on('over', (el, container, source) => {\n        this.$emit('over', el, container, source);\n      })\n      .on('out', (el, container, source) => {\n        this.$emit('out', el, container, source);\n      })\n      .on('cloned', (clone, original, type) => {\n        this.$emit('cloned', clone, original, type);\n      });\n      this.$emit('init', this.drake);\n    },\n\n    created() {\n      if (!this.stateMachineConfig) return;\n      this.machine = Machine(this.stateMachineConfig);\n    },\n  };\n</script>\n"]}]}